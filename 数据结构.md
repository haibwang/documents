### 数据结构绪论

- 数据
- 数据元素
- 数据项：数据项是数据不可分割的单元
- 数据对象
- 数据结构



#####  数据结构：逻辑结构和物理结构

- 逻辑结构
  - **集合结构**：元素间同属一个集合外，没有任何关系
  - **线性结构**：一对一的关系
  - **树形结构**：一对多关系
  - **图形结构**：多对多关系
- 物理结构：数据的逻辑结构在计算机中的存储形式
  - 顺序存储结构：地址连续的存储单元，数据间的物理关系和逻辑关系一致。（数组）
  - 链式结构：数据存储在任意存储单元， 

##### 抽象数据类型

数据类型：性质相同的数据值的集合以及一些操作

抽象数据额类型：



### 算法

算法是解决特定问题步骤的描述。

- 算法特性

  输入、输出、有穷、确定、可行

- 度量算法效率

  事后统计法：测试程序计时

  事先分析法：基本操作执行的次数

  **函数的渐进增长** ：当n大于一定值后，函数f（n）始终大于g(n)，就说函数f(n)增长渐进快于g(n)

   **判断算法的效率，应该判断最高阶的阶数**

- 算法的时间复杂度

  T（n）= O(f(n)),表示算法时间的增长率同f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。f(n)是问题规模n的函数。

  最优算法：随着n的增长，T(n)增长最慢的算法。

  常数阶：运行时间不会随着问题规模变化

  从快到慢常见5中大O运行时间：

  - **对数阶**O(logn)

    > 二分查找就是一种

  - **线性阶O(n)**

    > 常规遍历

  - **O(n*logn)**

  - **平方阶O(n^2)**

  - **O(n!)**

  循环的复杂度= 循环体的复杂度  * 循环次数

  平均时间复杂度

  xian最坏时间复杂度

- 算法的空间复杂度

  空间换时间

  S（n）= O(f(n)) ,f(n)是关于n的所占存储空间的函数





### 1 数组和链表(线性表)(选择排序算法)

线性表：零或多个数据元素的有限序列

线性表至多一个前区、至多一个后继



##### 线性表的抽象数据类型

##### 线性表的顺序存储结构

- 优点：
  - 快速查询，时间复杂度为O(1)；
  - 不需要增加数据时，增加额外的空间，因为初始化时已经定义了个最大空间。
- 缺点：
  - 增删时，后面所有的元素都需要动。时间复杂度为O(n)，平均时间复杂度也为O(n)；
  - 难以确定最大空间是多少；
  - 造成存储空间的碎片。

##### 线性表的链式存储结构

头指针：指向链表第一个元素的指针，无论链表是否为空，头指针都不为空

头结点：链表第一个元素结点之前的结点。有了头结点，在第一个结点处增删就和其他的一样了,不然还要判第一个结点是否为空

头插法、尾插法

- 优点:
  - 插入删除时间复杂度O(1)
- 缺点：
  - 查询时间复杂度O(n)
  - 空间动态分配，不受最大空间限制

| 操作 | 数组 | 链表 |
| ---- | ---- | ---- |
| 查询 | O(1)  常量时间 | O(n)  线性时间 |
| 插入删除 | O(n)  线性时间 | O(1)  常量时间 |


> *若线性表需要频繁的查询，很少增加删除，使用**顺序存储结构**；若频繁的增加删除，应该使用**链式存储结构***
>
> 数据空间不确定时，使用链式结构存储

数组链表：数组里面存放链表的头指针。

算法：**选择排序**：选择一个最大或最小值，放到另一个数组。时间复杂度O(n^2)

###### 静态链表

用数组描述的链表叫静态链表。

- 静态链表内存申请、释放的实现
  - 之所以叫静态链表，就是应为内存静态申请好了，静态链表的内存申请就是管理数组的内存。
- 静态链表的增删改查

**静态链表相较于数组，只解决了增删操作需要移动后面元素的问题**

###### 循环链表
将单链表的终端节点的指针指向其实头结点，就构成了循环链表。

从任意一个结点开始，都能够遍历整个链表。

###### 双向链表

在单链表的基础上添加一个前区指针。







### 2 栈和队列

栈(LIFO)和队列(FIFO)都是线性表

栈是只允许在表尾进行插入和删除的线性表

队列是只允许在一端进行插入，在另一端进行删除的线性表

##### 栈的抽象数据类型

栈操作：

- 初始化栈
- 销毁栈
- 判断栈是否为空
- 获取栈的长度
- 清空栈
- 获取栈顶
- 入栈
- 出栈

通常，空栈的长度定义为-1

栈的数据结构

```c
struct stack_t
{
    type data[MAX_SIZE];
    int top;
}
```

##### 两栈共享空间

数据的两端作为栈底，两个栈顶指针。当两个栈顶指针相差1时，栈满。

数据结构

```c
struct stack_t
{
    type data[MAX_SIZE];
    int top1;
    int top2;
}
```



栈操作带着栈标号，指明操作的时哪一个栈

使用场景：两个栈的空间需求具有相反的关系

##### 栈的链式结构存储

相比较顺序存储结构的栈，链栈不用定义栈的空间，空间大小是动态的。

##### 栈的作用

划分不同的关注层次，使思考范围缩小

##### 栈的应用

- 递归

  - 斐波那契数列的实现

- 四则运算表达式求值

  - 后缀表示法定义（逆波兰）

    后缀表达式是所有的运算符出现在数据的后面。

    平时标准的四则运算成为中则表达式，因为运算符都出现在 数据的而中间

  - 后缀表达式规则

    >从左到右依次进栈，遇到符号就把栈顶两个据去出根据符号进行运算，第一个数据最为左操作数，第二个数据作为右操作数，运算结果再进栈，然后依次进栈后面的数据和符号，直到结束。
    >
    >例如：9 3 1 - 3 * + 10 2 / + 的计算结果为20

  - 中缀表达式转后缀表达式

    > 从中缀表达式的左到右，依次输出数字，若为符号，并且该符号的优先级低于栈顶符号的优先级或为右括号，则栈顶符号依次出栈并输出直到左括号或优先级低于当前符号，并且将当前符号入栈，直到最后。









