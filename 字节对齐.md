**位域 ：**  

有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。**位段成员必须声明为int、unsigned int或signed int类型（short char long）。**

一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为：     

```c
struct 位域结构名     
{ 位域列表 };  
```

其中位域列表的形式为： 类型说明符 位域名：位域长度     
例如：     

```c
struct bs     
{     
int a:8;     
int b:2;     
int c:6;     
};  
```

位域变量的说明与结构变量说明的方式相同。 可采用先定义后说明，同时定义说明或者直接说明这三种方式。例如：     

```c
struct bs     
{     
int a:8;     
int b:2;     
int c:6;     
}data;   
```

说明data为bs变量，共占两个字节。其中位域a占8位，位域b占2位，位域c占6位。对于位域的定义尚有以下几点说明：     
\1. 如果一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。例如：     



```c
struct bs     
{     
unsigned a:4     
unsigned :0 /*空域*/     
unsigned b:4 /*从下一单元开始存放*/     
unsigned c:4     
}     
```



这个位域定义中，a占第一字节的4位，后4位填0表示不使用，b从第二字节开始，占用4位，c占用4位。     

2.位域的长度不能大于数据类型本身的长度，比如int类型就能超过32位二进位。

*3. *位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。例如：  *   *



```c
struct k     
{     
int a:1     
int :2 /*该2位不能使用*/     
int b:3     
int c:2     
};  
```



从以上分析可以看出，位域在本质上就是一种结构类型， 不过其成员是按二进位分配的。     
二、位域的使用位域的使用和结构成员的使用相同，其一般形式为： 位域变量名.位域名 位域允许用各种格式输出。     

```c
struct bs     
{     
    unsigned a:1;     
    unsigned b:3;     
    unsigned c:4;     
} bit,*pbit;     
bit.a=1;     
bit.b=7; //注意：位域的赋值不能超过该域所能表示的最大值，如b只有3位，能表示的最大数为7，若赋为8，就会出错   
bit.c=15;

printf("%d,%d,%d/n",bit.a,bit.b,bit.c);
pbit=&bit;
pbit->a=0;
pbit->b&=3;
pbit->c=1;
printf("%d,%d,%d/n",pbit->a,pbit->b,pbit->c);
```

上例程序中定义了位域结构bs，三个位域为a,b,c。说明了bs类型的变量bit和指向bs类型的指针变量pbit。这表示位域也是可以使用指针的。 
程序的9、10、11三行分别给三个位域赋值。(
应注重赋值不能超过该位域的答应范围)程序第12行以整型量格式输出三个域的内容。第13行把位域变量bit的地址送给指针变量pbit。第14行用指针
 方式给位域a重新赋值，赋为0。第15行使用了复合的位运算符"&="， 该行相当于： 
pbit->b=pbit->b&3位域b中原有值为7，与3作按位与运算的结果为3(111&011=011,十进制值为
 3)。同样，程序第16行中使用了复合位运算"="， 相当于： 
pbit->c=pbit->c1其结果为15。程序第17行用指针方式输出了这三个域的值。 

我们再来看看下面两个结构体定义：

```c
struct foo2 {
char    a : 2;
char    b : 3;
char    c : 1;
};

struct foo3 {
char    a : 2;
char    b : 3;
char    c : 7;
};
```



我们来打印一下这两个结构体的大小，我们得到的结果是：
sizeof(struct foo2) = 1
sizeof(struct foo3) = 2
显然都不是我们期望的，如果按照正常的内存对齐规则，
这两个结构体大小均应该为3才对，那么问题出在哪了呢？首先通过这种现象我们可以肯定的是：带有'位域'的结构体并不是按照每个域对齐的，而是将一些位域
 成员'捆绑'在一起做对齐的。以foo2为例，这个结构体中所有的成员都是char型的，而且三个位域占用的总空间为6 bit < 8 
bit(1 byte)，这时编译器会将这三个成员'捆绑'在一起做对齐，并且以最小空间作代价，这就是为什么我们得到sizeof(struct 
foo2) = 1这样的结果的原因了。再看看foo3这个结构体，同foo2一样，三个成员类型也都是char型，但是三个成员位域所占空间之和为9 
bit > 8 bit(1 
byte)，这里位域是不能跨越两个成员基本类型空间的，这时编译器将a和b两个成员'捆绑'按照char做对齐，而c单独拿出来以char类型做对齐，
 这样实际上在b和c之间出现了空隙，但这也是最节省空间的方法了。我们再看一种结构体定义：

```c
struct foo4 {
char    a : 2;
char    b : 3;
int c : 1;
};
```

在foo4中虽然三个位域所占用空间之和为6 bit < 8 bit(1 byte)，但是由于char和int的对齐系数是不同的，是不能捆绑在一起，那是不是a、b捆绑在一起按照char对齐，c单独按照int对齐呢？我们 打印一下sizeof(struct foo4)发现结果为8，也就是说编译器把a、b、c一起捆绑起来并以int做对齐了。就是说**不够一个类型的size时，将按其中最大的那个类型对齐。**此 处按int对齐。

C99规定int、unsigned int和bool可以作为位域类型，但编译器几乎都对此作了扩展，
允许其它类型类型的存在。
使用位域的主要目的是压缩存储，其大致规则为：

```
1) 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止
2) 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；
3) 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++，GCC采取压缩方式；
4) 如果位域字段之间穿插着非位域字段，则不进行压缩；
5) 整个结构体的总大小为最宽基本类型成员大小的整数倍。
```

```c
struct s1 
{ 
int i: 8; 
int j: 4; 
int a: 3; 
double b; 
}; 

struct s2 
{ 
int i: 8; 
int j: 4; 
double b; 
int a:3; 
}; 

printf("sizeof(s1)= %d/n", sizeof(s1)); 
printf("sizeof(s2)= %d/n", sizeof(s2)); 
result: 16, 24 
```

第一个结构体中，i，j，a共占15个位，不足8个字节，按double 8字节对齐，共16字节

第二个结构体中，i，j共占12位，不足8字节，按8字节对齐，a也按8字节对齐，加上double共8+8+8=24个字节

 